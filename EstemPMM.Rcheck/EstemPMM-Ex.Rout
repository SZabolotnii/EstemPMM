
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin24.4.0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "EstemPMM"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "EstemPMM-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('EstemPMM')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("DCOILWTICO")
> ### * DCOILWTICO
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DCOILWTICO
> ### Title: WTI Crude Oil Prices
> ### Aliases: DCOILWTICO
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(DCOILWTICO)
> head(DCOILWTICO)
  observation_date DCOILWTICO
1       2020-10-20      41.37
2       2020-10-21      39.88
3       2020-10-22      40.46
4       2020-10-23      39.73
5       2020-10-26      38.39
6       2020-10-27      39.34
> summary(DCOILWTICO$DCOILWTICO)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
  35.64   68.26   74.36   75.89   82.50  123.64      56 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DCOILWTICO", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ar_pmm2")
> ### * ar_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ar_pmm2
> ### Title: Fit an AR model using PMM2 (wrapper)
> ### Aliases: ar_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Fit AR(2) model with default variant
> ##D x <- arima.sim(n = 200, list(ar = c(0.7, -0.3)))
> ##D fit1 <- ar_pmm2(x, order = 2)
> ##D coef(fit1)
> ##D 
> ##D # Compare variants
> ##D fit2 <- ar_pmm2(x, order = 2, pmm2_variant = "unified_iterative")
> ##D fit3 <- ar_pmm2(x, order = 2, pmm2_variant = "linearized")
> ## End(Not run)
>   
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ar_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("arima_pmm2")
> ### * arima_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: arima_pmm2
> ### Title: Fit an ARIMA model using PMM2 (wrapper)
> ### Aliases: arima_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Fit ARIMA(1,1,1) model to non-stationary series
> ##D x <- cumsum(arima.sim(n = 200, list(ar = 0.6, ma = -0.4)))
> ##D fit1 <- arima_pmm2(x, order = c(1, 1, 1))
> ##D coef(fit1)
> ##D 
> ##D # ARIMA(2,1,0) - random walk with AR(2) innovations
> ##D x2 <- cumsum(arima.sim(n = 250, list(ar = c(0.7, -0.3))))
> ##D fit2 <- arima_pmm2(x2, order = c(2, 1, 0), pmm2_variant = "unified_global")
> ##D 
> ##D # ARIMA(0,2,2) - double differencing with MA(2)
> ##D x3 <- cumsum(cumsum(arima.sim(n = 300, list(ma = c(0.5, 0.3)))))
> ##D fit3 <- arima_pmm2(x3, order = c(0, 2, 2), pmm2_variant = "unified_iterative")
> ## End(Not run)
>   
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("arima_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("arma_pmm2")
> ### * arma_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: arma_pmm2
> ### Title: Fit an ARMA model using PMM2 (wrapper)
> ### Aliases: arma_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Fit ARMA(2,1) model
> ##D x <- arima.sim(n = 250, list(ar = c(0.7, -0.3), ma = 0.5))
> ##D fit1 <- arma_pmm2(x, order = c(2, 1))
> ##D coef(fit1)
> ##D 
> ##D # Try iterative variant for better accuracy
> ##D fit2 <- arma_pmm2(x, order = c(2, 1), pmm2_variant = "unified_iterative")
> ##D 
> ##D # Higher-order ARMA
> ##D x2 <- arima.sim(n = 300, list(ar = c(0.6, -0.2), ma = c(0.4, 0.3)))
> ##D fit3 <- arma_pmm2(x2, order = c(2, 2), pmm2_variant = "unified_global")
> ## End(Not run)
>   
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("arma_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compare_sar_methods")
> ### * compare_sar_methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compare_sar_methods
> ### Title: Compare SAR model estimation methods
> ### Aliases: compare_sar_methods
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Generate seasonal data
> ##D y <- arima.sim(120, list(ar = 0.7, seasonal = list(sar = 0.5, period = 12)))
> ##D 
> ##D # Compare methods
> ##D compare_sar_methods(y, order = c(1, 1), period = 12)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compare_sar_methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("create_sar_matrix")
> ### * create_sar_matrix
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: create_sar_matrix
> ### Title: Create design matrix for seasonal AR model
> ### Aliases: create_sar_matrix
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Simple SAR(1)_12 model
> ##D x <- rnorm(120)
> ##D X <- create_sar_matrix(x, p = 0, P = 1, s = 12)
> ##D 
> ##D # AR(1) + SAR(1)_12 additive model
> ##D X <- create_sar_matrix(x, p = 1, P = 1, s = 12)
> ##D 
> ##D # AR(1) x SAR(1)_12 multiplicative model
> ##D X <- create_sar_matrix(x, p = 1, P = 1, s = 12, multiplicative = TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("create_sar_matrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("create_sarma_matrix")
> ### * create_sarma_matrix
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: create_sarma_matrix
> ### Title: Create design matrix for seasonal ARMA model
> ### Aliases: create_sarma_matrix
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Simple SARMA(1,0) x (1,0)_12 model (AR+SAR, no MA)
> ##D x <- rnorm(120)
> ##D residuals <- rnorm(120)
> ##D X <- create_sarma_matrix(x, residuals, p = 1, P = 1, q = 0, Q = 0, s = 12)
> ##D 
> ##D # Full SARMA(1,1) x (1,1)_12 model
> ##D X <- create_sarma_matrix(x, residuals, p = 1, P = 1, q = 1, Q = 1, s = 12)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("create_sarma_matrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lm_pmm2")
> ### * lm_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lm_pmm2
> ### Title: PMM2: Main function for PMM2 (S=2)
> ### Aliases: lm_pmm2
> 
> ### ** Examples
> 
> set.seed(123)
> n <- 80
> x <- rnorm(n)
> y <- 2 + 3 * x + rt(n, df = 3)
> dat <- data.frame(y = y, x = x)
> 
> fit <- lm_pmm2(y ~ x, data = dat)
> summary(fit, formula = y ~ x, data = dat)
PMM2 estimation results
Call:
lm_pmm2(formula = y ~ x, data = dat)

Coefficients:
[1] 2.139976 2.882423

Central moments of initial residuals:
  m2 = 2.543763 
  m3 = 6.010714 
  m4 = 49.22114 

Theoretical characteristics of PMM2 (S = 2):
  c3 = 1.481532 
  c4 = 4.606735 
  g  = 0.6677728  (expected ratio Var[PMM2]/Var[OLS])

Algorithm information:
  Convergence status: TRUE 
  Iterations: 3 

Approximate statistical inference via bootstrap (B=100):
  Estimate Std.Error  t.value p.value conf.low conf.high
1 2.139976 0.1645314 13.00649       0 1.776381  2.403036
2 2.882423 0.1564490 18.42404       0 2.593175  3.197701
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lm_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ma_pmm2")
> ### * ma_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ma_pmm2
> ### Title: Fit an MA model using PMM2 (wrapper)
> ### Aliases: ma_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Fit MA(1) model with linearized variant (recommended)
> ##D x <- arima.sim(n = 200, list(ma = 0.6))
> ##D fit1 <- ma_pmm2(x, order = 1, pmm2_variant = "linearized")
> ##D coef(fit1)
> ##D 
> ##D # Compare with unified_global (best accuracy)
> ##D fit2 <- ma_pmm2(x, order = 1, pmm2_variant = "unified_global")
> ##D 
> ##D # Higher-order MA
> ##D x2 <- arima.sim(n = 300, list(ma = c(0.7, -0.4, 0.2)))
> ##D fit3 <- ma_pmm2(x2, order = 3, pmm2_variant = "linearized")
> ## End(Not run)
>   
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ma_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("predict-PMM2fit-method")
> ### * predict-PMM2fit-method
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict,PMM2fit-method
> ### Title: Prediction method for PMM2fit objects
> ### Aliases: predict,PMM2fit-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Fit model
> ##D fit <- lm_pmm2(mpg ~ wt + hp, data = mtcars)
> ##D 
> ##D # Predict on new data
> ##D newdata <- data.frame(wt = c(2.5, 3.0), hp = c(100, 150))
> ##D predictions <- predict(fit, newdata = newdata)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict-PMM2fit-method", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sar_pmm2")
> ### * sar_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sar_pmm2
> ### Title: Fit Seasonal AR model using PMM2 method
> ### Aliases: sar_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Generate synthetic seasonal data
> ##D n <- 120
> ##D y <- arima.sim(n = n, list(ar = 0.7, seasonal = list(sar = 0.5, period = 12)))
> ##D 
> ##D # Fit SAR(1,1)_12 model with PMM2
> ##D fit <- sar_pmm2(y, order = c(1, 1), season = list(period = 12))
> ##D summary(fit)
> ##D 
> ##D # Simple seasonal model (no non-seasonal component)
> ##D fit_pure_sar <- sar_pmm2(y, order = c(0, 1), season = list(period = 12))
> ##D 
> ##D # Compare with OLS
> ##D fit_ols <- sar_pmm2(y, order = c(1, 1), season = list(period = 12), method = "ols")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sar_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sarima_pmm2")
> ### * sarima_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sarima_pmm2
> ### Title: Fit a Seasonal ARIMA model using PMM2 method
> ### Aliases: sarima_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Generate synthetic data
> ##D set.seed(123)
> ##D n <- 200
> ##D y <- arima.sim(n = n, list(
> ##D   order = c(1, 1, 1),
> ##D   seasonal = list(order = c(1, 1, 1), period = 12)
> ##D ))
> ##D 
> ##D # Fit SARIMA(1,1,1) x (1,1,1)_12 model
> ##D fit <- sarima_pmm2(y,
> ##D   order = c(1, 1, 1, 1),
> ##D   seasonal = list(order = c(1, 1), period = 12)
> ##D )
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sarima_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sarma_pmm2")
> ### * sarma_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sarma_pmm2
> ### Title: Fit a Seasonal ARMA model using PMM2 method
> ### Aliases: sarma_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Generate synthetic seasonal data with SARMA structure
> ##D set.seed(123)
> ##D n <- 200
> ##D y <- arima.sim(n = n, list(
> ##D   ar = 0.5, ma = 0.3,
> ##D   seasonal = list(sar = 0.6, sma = 0.4, period = 12)
> ##D ))
> ##D 
> ##D # Fit SARMA(1,1,1,1)_12 model with PMM2
> ##D fit <- sarma_pmm2(y, order = c(1, 1, 1, 1), season = list(period = 12))
> ##D summary(fit)
> ##D 
> ##D # Pure seasonal model (no non-seasonal components)
> ##D fit_pure <- sarma_pmm2(y, order = c(0, 1, 0, 1), season = list(period = 12))
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sarma_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sma_pmm2")
> ### * sma_pmm2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sma_pmm2
> ### Title: Fit a Seasonal MA model using PMM2
> ### Aliases: sma_pmm2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Generate synthetic seasonal data
> ##D set.seed(123)
> ##D n <- 120
> ##D s <- 12
> ##D theta <- 0.6
> ##D 
> ##D # Gamma innovations (asymmetric)
> ##D innov <- rgamma(n, shape = 2, scale = 1) - 2
> ##D y <- numeric(n)
> ##D for (t in 1:n) {
> ##D   ma_term <- if (t > s) theta * innov[t - s] else 0
> ##D   y[t] <- innov[t] + ma_term
> ##D }
> ##D 
> ##D # Fit SMA(1)_12 model with PMM2
> ##D fit <- sma_pmm2(y, order = 1, season = list(period = 12))
> ##D summary(fit)
> ##D 
> ##D # Compare with CSS
> ##D fit_css <- sma_pmm2(y, order = 1, season = list(period = 12), method = "css")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sma_pmm2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.25 0.014 0.343 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
